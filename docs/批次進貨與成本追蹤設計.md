# 批次進貨與成本追蹤 - 資料結構與流程設計

## 一、設計目標

1. **支援每批進貨不同成本**：同一 SKU 產品，不同批次可有不同進貨成本
2. **成本計算方式**：提供「加權平均」與「FIFO」兩種策略
3. **與現有系統相容**：不破壞現有 Inventory、Transaction 流程

---

## 二、資料結構

### 2.1 進貨單 (PurchaseOrder)

| 欄位 | 型別 | 說明 |
|------|------|------|
| `id` | string | 文件 ID（自動產生） |
| `poNumber` | string | 進貨單號（如 PO-20250224-001） |
| `status` | enum | `draft` \| `submitted` \| `partial` \| `received` \| `cancelled` |
| `supplierId` | string | 供應商 ID（可選，若有 suppliers collection） |
| `supplierName` | string | 供應商名稱 |
| `warehouseId` | string | 入庫倉庫 ID |
| `userId` | string | 收貨人（stockist）ID，庫存歸屬 |
| `items` | PurchaseOrderItem[] | 進貨明細 |
| `totals` | { subtotal, tax?, grandTotal } | 金額彙總 |
| `receivedAt` | number? | 實際收貨時間 |
| `notes` | string? | 備註 |
| `createdAt` | number | 建立時間 |
| `updatedAt` | number | 更新時間 |
| `createdBy` | string | 建立者 ID |

### 2.2 進貨單明細 (PurchaseOrderItem)

| 欄位 | 型別 | 說明 |
|------|------|------|
| `productId` | string | 產品 SKU |
| `productName` | string | 產品名稱（快照） |
| `quantity` | number | 進貨數量 |
| `unitCost` | number | 本批單位成本 |
| `receivedQuantity` | number | 已收數量（部分收貨用） |
| `total` | number | 小計 (quantity × unitCost) |

### 2.3 庫存批次 (InventoryBatch)

每個 (userId, productId) 下可有多個批次，依進貨時間排序，出貨時依 FIFO 扣減。

| 欄位 | 型別 | 說明 |
|------|------|------|
| `id` | string | 批次 ID |
| `userId` | string | 庫存歸屬者 |
| `productId` | string | 產品 SKU |
| `purchaseOrderId` | string | 來源進貨單 ID |
| `quantity` | number | 本批剩餘數量 |
| `unitCost` | number | 本批單位成本 |
| `receivedAt` | number | 進貨時間（用於 FIFO 排序） |
| `createdAt` | number | 建立時間 |

**Collection 建議**：`inventoryBatches`，查詢條件 `userId` + `productId`，排序 `receivedAt` 升序。

### 2.4 擴充 Inventory（既有結構）

保留現有 `Inventory` 作為彙總視圖，新增欄位以支援批次：

| 新增/調整欄位 | 型別 | 說明 |
|--------------|------|------|
| `costingMethod` | enum | `weighted_avg` \| `fifo`，預設 `weighted_avg` |
| `cost` | number | 加權平均時：平均成本；FIFO 時：最新批次成本（顯示用） |
| `marketValue` | number | quantityOnHand × cost |
| `batches` | InventoryBatch[]? | 若為 FIFO，可快取批次摘要（非必須，可即時查） |

**向後相容**：既有 Inventory 無 `costingMethod` 時，視為 `weighted_avg`，`cost` 維持現有邏輯。

---

## 三、成本計算策略

### 3.1 加權平均 (Weighted Average)

**進貨時**：
```
新平均成本 = (舊庫存 × 舊成本 + 進貨數量 × 進貨單價) / (舊庫存 + 進貨數量)
```

**優點**：實作簡單，不需批次表  
**缺點**：無法追蹤每批實際成本

### 3.2 FIFO (First In, First Out)

**進貨時**：新增一筆 `InventoryBatch` 記錄

**出貨時**：依 `receivedAt` 升序，從最早批次開始扣減

**優點**：可追蹤每批成本，符合多數會計實務  
**缺點**：需維護批次表，出貨邏輯較複雜

---

## 四、流程設計

### 4.1 進貨流程（建立進貨單 → 收貨）

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  1. 建立進貨單   │ ──► │  2. 確認收貨     │ ──► │  3. 更新庫存     │
│  (draft)        │     │  (received)      │     │  + 批次/成本     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**步驟 1：建立進貨單**
- 選擇產品、數量、單位成本
- 狀態：`draft`
- 可編輯、可刪除

**步驟 2：確認收貨**
- 將狀態改為 `received`（或 `partial` 若支援部分收貨）
- 觸發庫存更新

**步驟 3：更新庫存（依 costingMethod）**

| 策略 | 動作 |
|------|------|
| **加權平均** | 1. 取得或建立 Inventory<br>2. 計算新平均成本<br>3. 更新 quantityOnHand、cost、marketValue<br>4. 新增 movement |
| **FIFO** | 1. 建立 InventoryBatch 記錄<br>2. 取得或建立 Inventory<br>3. 更新 quantityOnHand（加總各批次）<br>4. 更新 cost 為最新批次單價（顯示用）<br>5. 新增 movement |

### 4.2 出貨流程（銷售 / 調撥 / 借出）

**加權平均**：與現有邏輯相同，直接扣減 Inventory.quantityOnHand，成本用 Inventory.cost

**FIFO**：
1. 查詢該 (userId, productId) 下所有批次，依 `receivedAt` 升序
2. 從最早批次開始扣減，直到滿足出貨數量
3. 若批次 quantity 扣完，標記或刪除該批次
4. 更新 Inventory.quantityOnHand
5. 計算本次出貨成本（各批次扣減量 × 該批 unitCost 加總）

### 4.3 與現有 Transaction 的整合

- **PURCHASE**：可改為「建立進貨單」或「直接收貨」兩種入口
- **SALE / TRANSFER / LOAN**：出貨時呼叫新的 `InventoryService.deductWithCosting(userId, items, costingMethod)`，內部依策略處理

---

## 五、API / Service 設計

### 5.1 PurchaseOrderService

```typescript
// 建立進貨單
create(po: Omit<PurchaseOrder, 'id' | 'createdAt' | 'updatedAt'>): Promise<PurchaseOrder>

// 確認收貨（觸發庫存更新）
receive(poId: string): Promise<void>

// 查詢
getById(id: string): Promise<PurchaseOrder | null>
getByUser(userId: string, status?: PurchaseOrderStatus): Promise<PurchaseOrder[]>
```

### 5.2 InventoryBatchService（FIFO 用）

```typescript
// 新增批次
addBatch(userId: string, productId: string, quantity: number, unitCost: number, purchaseOrderId: string): Promise<InventoryBatch>

// FIFO 扣減，回傳實際扣減成本
deductFifo(userId: string, productId: string, quantity: number): Promise<{ deducted: number; costUsed: number }>

// 查詢某產品所有批次
getBatchesByUserAndProduct(userId: string, productId: string): Promise<InventoryBatch[]>
```

### 5.3 擴充 InventoryService

```typescript
// 進貨（加權平均）
addWithWeightedAvg(id: string, quantity: number, unitCost: number, reference: string, current: Inventory): Promise<void>

// 進貨（FIFO）- 由 PurchaseOrderService.receive 呼叫 InventoryBatchService
// 出貨 - 依 Inventory.costingMethod 分派
deductWithCosting(userId: string, items: TransactionItem[], reference: string): Promise<void>
```

---

## 六、Firestore Collections

| Collection | 說明 |
|------------|------|
| `purchaseOrders` | 進貨單 |
| `inventoryBatches` | 庫存批次（FIFO 用） |
| `inventory` | 既有，擴充 costingMethod |
| `products` | 既有，不變 |

**索引建議**：
- `inventoryBatches`：`userId` + `productId` + `receivedAt`（升序）
- `purchaseOrders`：`userId` + `status` + `createdAt`（降序）

---

## 七、實作階段建議

### Phase 1：進貨單 + 加權平均（最小可行）
1. 新增 `PurchaseOrder`、`PurchaseOrderItem` 型別
2. 實作 `PurchaseOrderService`、進貨單建立/收貨 API
3. 收貨時更新 Inventory 使用加權平均計算
4. 進貨單列表、建立、收貨 UI

### Phase 2：FIFO 批次追蹤
1. 新增 `InventoryBatch` 型別與 collection
2. 實作 `InventoryBatchService`
3. Inventory 新增 `costingMethod`，可選 FIFO
4. 出貨時依策略扣減

### Phase 3：報表與查詢
1. 批次成本查詢
2. 進貨歷史報表
3. 成本變動分析

---

## 八、型別定義（TypeScript 草案）

```typescript
// 進貨單狀態
export enum PurchaseOrderStatus {
  DRAFT = 'draft',
  SUBMITTED = 'submitted',
  PARTIAL = 'partial',
  RECEIVED = 'received',
  CANCELLED = 'cancelled',
}

// 成本計算方式
export enum CostingMethod {
  WEIGHTED_AVG = 'weighted_avg',
  FIFO = 'fifo',
}

export interface PurchaseOrderItem {
  productId: string;
  productName: string;
  quantity: number;
  unitCost: number;
  receivedQuantity?: number;
  total: number;
}

export interface PurchaseOrder {
  id?: string;
  poNumber: string;
  status: PurchaseOrderStatus;
  supplierId?: string;
  supplierName?: string;
  warehouseId?: string;
  userId: string;
  items: PurchaseOrderItem[];
  totals: { subtotal: number; tax?: number; grandTotal: number };
  receivedAt?: number;
  notes?: string;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string;
}

export interface InventoryBatch {
  id?: string;
  userId: string;
  productId: string;
  purchaseOrderId: string;
  quantity: number;
  unitCost: number;
  receivedAt: number;
  createdAt?: number;
}
```

---

## 九、注意事項

1. **Product.costPrice**：可保留為「參考成本」或「上次進貨成本」，實際庫存成本以 Inventory / Batch 為準
2. **既有庫存遷移**：啟用前可將現有 Inventory 視為「單一批次」，或僅對新進貨啟用批次
3. **並發**：收貨、出貨建議使用 Firestore transaction 確保數量一致
